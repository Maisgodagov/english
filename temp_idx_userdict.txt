   1: import { useEffect, useMemo, useRef, useState } from 'react';
   2: import { ActivityIndicator, Alert, FlatList, Animated, Dimensions, Easing } from 'react-native';
   3: import styled from 'styled-components/native';
   4: import { Audio as ExpoAudio } from 'expo-av';
   5: import { useNavigation } from '@react-navigation/native';
   6: 
   7: import { useAppDispatch, useAppSelector } from '@app/store/hooks';
   8: import {
   9:   fetchUserDictionary,
  10:   removeUserDictionaryEntry,
  11:   selectDictionaryItems,
  12:   selectDictionaryStatus,
  13:   addUserDictionaryEntry,
  14: } from '@features/dictionary/model/dictionarySlice';
  15: import { SurfaceCard, Typography } from '@shared/ui';
  16: 
  17: const Screen = styled.View`
  18:   flex: 1;
  19:   background-color: ${({ theme }) => theme.colors.backgroundAlt};
  20:   padding: 64px 20px 20px;
  21:   gap: 20px;
  22: `;
  23: 
  24: const TopRow = styled.View`
  25:   flex-direction: row;
  26:   justify-content: space-between;
  27:   align-items: center;
  28: `;
  29: 
  30: const PrimaryButton = styled.TouchableOpacity`
  31:   background-color: ${({ theme }) => theme.colors.primary};
  32:   border-radius: ${({ theme }) => theme.radius.md}px;
  33:   padding: 12px 16px;
  34: `;
  35: 
  36: const ButtonLabel = styled(Typography)`
  37:   color: #ffffff;
  38:   font-weight: 600;
  39: `;
  40: 
  41: const SearchPanel = styled.View`
  42:   padding: 16px 20px;
  43:   background-color: #1F2937; /* fixed dark background */
  44:   border-bottom-left-radius: ${({ theme }) => theme.radius.lg}px;
  45:   border-bottom-right-radius: ${({ theme }) => theme.radius.lg}px;
  46:   gap: 12px;
  47:   elevation: 6;
  48: `;
  49: 
  50: const SearchRow = styled.View`
  51:   flex-direction: row;
  52:   gap: 12px;
  53: `;
  54: 
  55: const SearchInput = styled.TextInput`
  56:   flex: 1;
  57:   background-color: #ffffff;
  58:   border-radius: ${({ theme }) => theme.radius.md}px;
  59:   padding: 12px 14px;
  60:   font-size: 16px;
  61:   border-width: 1px;
  62:   border-color: ${({ theme }) => theme.colors.border};
  63: `;
  64: 
  65: const Muted = styled(Typography)`
  66:   color: ${({ theme }) => theme.colors.textSecondary};
  67: `;
  68: 
  69: const Inline = styled.View`
  70:   flex-direction: row;
  71:   align-items: center;
  72:   justify-content: space-between;
  73: `;
  74: 
  75: const LightTitle = styled(Typography)`
  76:   color: #F9FAFB;
  77: `;
  78: 
  79: const LightButtonLabel = styled(Typography)`
  80:   color: #E5E7EB;
  81: `;
  82: 
  83: const WordCard = styled(SurfaceCard)`
  84:   gap: 12px;
  85: `;
  86: 
  87: const Row = styled.View`
  88:   flex-direction: row;
  89:   align-items: center;
  90:   justify-content: space-between;
  91:   gap: 12px;
  92: `;
  93: 
  94: const AudioButton = styled.TouchableOpacity`
  95:   background-color: rgba(30, 136, 229, 0.12);
  96:   border-radius: ${({ theme }) => theme.radius.sm}px;
  97:   padding: 6px 12px;
  98: `;
  99: 
 100: const AudioLabel = styled(Typography)`
 101:   color: ${({ theme }) => theme.colors.primary};
 102: `;
 103: 
 104: const SmallButton = styled.TouchableOpacity`
 105:   padding: 6px 10px;
 106:   border-radius: ${({ theme }) => theme.radius.sm}px;
 107:   background-color: ${({ theme }) => theme.colors.surfaceAlt};
 108: `;
 109: 
 110: const SmallButtonLabel = styled(Typography)`
 111:   color: ${({ theme }) => theme.colors.text};
 112: `;
 113: 
 114: const Separator = styled.View`
 115:   height: 16px;
 116: `;
 117: 
 118: const EmptyState = styled(Typography)`
 119:   text-align: center;
 120:   color: ${({ theme }) => theme.colors.textSecondary};
 121: `;
 122: 
 123: export const UserDictionaryScreen = () => {
 124:   const navigation = useNavigation();
 125:   const dispatch = useAppDispatch();
 126:   const profile = useAppSelector((s) => s.user.profile);
 127:   const items = useAppSelector(selectDictionaryItems);
 128:   const status = useAppSelector(selectDictionaryStatus);
 129: 
 130:   const [playingId, setPlayingId] = useState<string | null>(null);
 131:   const soundRef = useRef<ExpoAudio.Sound | null>(null);
 132: 
 133:   // Sliding search panel state
 134:   const panelHeight = Math.round(Dimensions.get('window').height * 0.5);
 135:   const minPanelHeight = Math.round(Dimensions.get('window').height * 0.4);
 136:   const slideY = useRef(new Animated.Value(-panelHeight)).current;
 137:   const [searchOpen, setSearchOpen] = useState(false);
 138:   const [query, setQuery] = useState('');
 139:   const [searchLoading, setSearchLoading] = useState(false);
 140:   const [searchError, setSearchError] = useState<string | null>(null);
 141:   const [results, setResults] = useState<{
 142:     word: string;
 143:     translation: string;
 144:     partOfSpeech?: string;
 145:     transcription?: string;
 146:     audioUrl?: string;
 147:   }[]>([]);
 148:   const [optimistic, setOptimistic] = useState<Set<string>>(new Set());
 149: 
 150:   useEffect(() => {
 151:     if (profile?.id) {
 152:       dispatch(fetchUserDictionary({ userId: profile.id }));
 153:     }
 154:   }, [dispatch, profile?.id]);
 155: 
 156:   useEffect(() => {
 157:     return () => {
 158:       if (soundRef.current) {
 159:         soundRef.current.unloadAsync().catch(() => undefined);
 160:         soundRef.current = null;
 161:       }
 162:     };
 163:   }, []);
 164: 
 165:   const playAudio = async (id: string, url: string) => {
 166:     try {
 167:       if (playingId === id && soundRef.current) {
 168:         await soundRef.current.stopAsync();
 169:         await soundRef.current.unloadAsync();
 170:         soundRef.current = null;
 171:         setPlayingId(null);
 172:         return;
 173:       }
 174:       if (soundRef.current) {
 175:         await soundRef.current.stopAsync().catch(() => undefined);
 176:         await soundRef.current.unloadAsync().catch(() => undefined);
 177:         soundRef.current = null;
 178:       }
 179:       const { sound } = await ExpoAudio.Sound.createAsync({ uri: url });
 180:       soundRef.current = sound;
 181:       setPlayingId(id);
 182:       await sound.playAsync();
 183:       sound.setOnPlaybackStatusUpdate((s) => {
 184:         if (!s.isLoaded) return;
 185:         if ((s as any).didJustFinish) {
 186:           setPlayingId((current) => (current === id ? null : current));
 187:           sound.unloadAsync().catch(() => undefined);
 188:           soundRef.current = null;
 189:         }
 190:       });
 191:     } catch {
 192:       Alert.alert('\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u043E\u0441\u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0441\u0442\u0438 \u0430\u0443\u0434\u0438\u043E');
 193:       setPlayingId((current) => (current === id ? null : current));
 194:     }
 195:   };
 196: 
 197:   const openSearch = () => {
 198:     setSearchOpen(true);
 199:     slideY.stopAnimation();
 200:     slideY.setValue(-panelHeight);
 201:     Animated.timing(slideY, {
 202:       toValue: 0,
 203:       duration: 280,
 204:       easing: Easing.out(Easing.cubic),
 205:       useNativeDriver: true,
 206:     }).start();
 207:   };
 208: 
 209:   const closeSearch = () => {
 210:     Animated.timing(slideY, {
 211:       toValue: -panelHeight,
 212:       duration: 260,
 213:       easing: Easing.in(Easing.cubic),
 214:       useNativeDriver: true,
 215:     }).start(({ finished }) => {
 216:       if (finished) {
 217:         setSearchOpen(false);
 218:         setQuery('');
 219:         setResults([]);
 220:         setSearchError(null);
 221:         setSearchLoading(false);
 222:       }
 223:     });
 224:   };
 225: 
 226:   const detectLang = (input: string) => {
 227:     const hasCyrillic = /[\p{Script=Cyrillic}]/u.test(input);
 228:     const hasLatin = /[A-Za-z]/.test(input);
 229:     if (hasCyrillic && !hasLatin) return 'ru-en';
 230:     return 'en-ru';
 231:   };
 232: 
 233:   const submitSearch = async () => {
 234:     const text = query.trim();
 235:     if (!text) return;
 236:     const apiKey = process.env.EXPO_PUBLIC_YANDEX_DICT_KEY;
 237:     if (!apiKey) {
 238:       setSearchError('\u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u043A\u043B\u044E\u0447 API. \u0423\u043A\u0430\u0436\u0438\u0442\u0435 EXPO_PUBLIC_YANDEX_DICT_KEY.');
 239:       return;
 240:     }
 241:     setSearchLoading(true);
 242:     setSearchError(null);
 243:     try {
 244:       const lang = detectLang(text);
 245:       const params = new URLSearchParams({ key: apiKey, lang, text });
 246:       const url = `https://dictionary.yandex.net/api/v1/dicservice.json/lookup?${params.toString()}`;
 247:       const res = await fetch(url);
 248:       if (!res.ok) throw new Error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430: ${res.status}`);
 249:       const data = (await res.json()) as { def?: Array<{ text?: string; ts?: string; pos?: string; tr?: Array<{ text?: string; pos?: string }> }>; };
 250:       const next: { word: string; translation: string; partOfSpeech?: string; transcription?: string; audioUrl?: string }[] = [];
 251:       const defs = data.def ?? [];
 252:       defs.forEach((d) => {
 253:         const base = (d.text ?? text).trim();
 254:         (d.tr ?? []).forEach((t) => {
 255:           if (!t.text) return;
 256:           next.push({ word: base, translation: t.text, partOfSpeech: t.pos ?? d.pos ?? undefined, transcription: d.ts ?? undefined });
 257:         });
 258:       });
 259:       // Try to fetch audio for English side via Free Dictionary API
 260:       const FREEDICT_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en';
 261:       const englishWords = new Set<string>();
 262:       for (const item of next) {
 263:         const englishWord = lang === 'en-ru' ? item.word : item.translation;
 264:         if (/^[A-Za-z][A-Za-z\-']*$/.test(englishWord)) {
 265:           englishWords.add(englishWord.toLowerCase());
 266:         }
 267:       }
 268:       const audioMap = new Map<string, { audio?: string; transcription?: string }>();
 269:       await Promise.all(
 270:         Array.from(englishWords).map(async (w) => {
 271:           try {
 272:             const r = await fetch(`${FREEDICT_URL}/${encodeURIComponent(w)}`);
 273:             if (!r.ok) return;
 274:             const j = (await r.json()) as Array<{ phonetics?: Array<{ audio?: string; text?: string }> }>;
 275:             const phonetics = j.flatMap((e) => e.phonetics || []);
 276:             const withAudio = phonetics.find((p) => p.audio) || phonetics[0];
 277:             if (withAudio) {
 278:               audioMap.set(w, { audio: withAudio.audio, transcription: withAudio.text });
 279:             }
 280:           } catch {
 281:             // ignore
 282:           }
 283:         }),
 284:       );
 285:       const withAudio = next.map((item) => {
 286:         const englishWord = (lang === 'en-ru' ? item.word : item.translation).toLowerCase();
 287:         const a = audioMap.get(englishWord);
 288:         return { ...item, audioUrl: a?.audio, transcription: item.transcription || a?.transcription };
 289:       });
 290:       setResults(withAudio.slice(0, 20));
 291:     } catch (e) {
 292:       setSearchError(e instanceof Error ? e.message : '\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A');
 293:       setResults([]);
 294:     } finally {
 295:       setSearchLoading(false);
 296:     }
 297:   };
 298: 
 299:   const content = useMemo(() => {
 300:     if (status === 'loading') {
 301:       return <ActivityIndicator size="large" color="#1E88E5" />;
 302:     }
 303:     if (!items.length) {
 304:       return <EmptyState>{'\u0412\u0430\u0448 \u0441\u043B\u043E\u0432\u0430\u0440\u044C \u043F\u0443\u0441\u0442. \u041D\u0430\u0439\u0434\u0438\u0442\u0435 \u0441\u043B\u043E\u0432\u043E \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u0435 \u0432 \u0441\u043B\u043E\u0432\u0430\u0440\u044C.'}</EmptyState>;
 305:     }
 306:     return (
 307:       <FlatList
 308:         data={items}
 309:         keyExtractor={(item) => item.id}
 310:         showsVerticalScrollIndicator={false}
 311:         ItemSeparatorComponent={() => <Separator />}
 312:         renderItem={({ item }) => (
 313:           <WordCard padded>
 314:             <Row>
 315:               <Typography variant="subtitle">{item.word}</Typography>
 316:               {item.audioUrl ? (
 317:                 <AudioButton onPress={() => playAudio(`${item.id}-saved`, item.audioUrl!)}>
 318:                   <AudioLabel variant="caption">{playingId === `${item.id}-saved` ? '\u0421\u0442\u043E\u043F' : '\u041F\u0440\u043E\u0441\u043B\u0443\u0448\u0430\u0442\u044C'}</AudioLabel>
 319:                 </AudioButton>
 320:               ) : null}
 321:             </Row>
 322:             {item.transcription ? <Typography variant="caption">{item.transcription}</Typography> : null}
 323:             {item.partOfSpeech ? <Typography variant="caption">{item.partOfSpeech}</Typography> : null}
 324:             <Row>
 325:               <Typography>{'\u2014 '}{item.translation}</Typography>
 326:               <SmallButton onPress={() => { if (!profile?.id) return; dispatch(removeUserDictionaryEntry({ userId: profile.id, id: item.id })); }}>
 327:                 <SmallButtonLabel variant="caption">{'\u0423\u0434\u0430\u043B\u0438\u0442\u044C'}</SmallButtonLabel>
 328:               </SmallButton>
 329:             </Row>
 330:           </WordCard>
 331:         )}
 332:         contentContainerStyle={{ paddingBottom: 32 }}
 333:       />
 334:     );
 335:   }, [dispatch, items, playingId, profile?.id, status]);
 336: 
 337:   return (
 338:     <Screen>
 339:       <TopRow>
 340:         <Typography variant="title">{'\u041C\u043E\u0439 \u0441\u043B\u043E\u0432\u0430\u0440\u044C'}</Typography>
 341:         <PrimaryButton onPress={openSearch}>
 342:           <ButtonLabel>{'\u041D\u0430\u0439\u0442\u0438 \u0441\u043B\u043E\u0432\u043E'}</ButtonLabel>
 343:         </PrimaryButton>
 344:       </TopRow>
 345:       {content}
 346:       <Animated.View
 347:         pointerEvents={searchOpen ? 'auto' : 'none'}
 348:         style={{
 349:           position: 'absolute',
 350:           top: 64,
 351:           left: 0,
 352:           right: 0,
 353:           height: panelHeight,
 354:           minHeight: minPanelHeight,
 355:           transform: [{ translateY: slideY }],
 356:           zIndex: 10,
 357:         }}
 358:       >
 359:         <SearchPanel>
 360:           <Inline>
 361:             <LightTitle variant="subtitle">{'\u041F\u043E\u0438\u0441\u043A \u0441\u043B\u043E\u0432\u0430'}</LightTitle>
 362:             <SmallButton onPress={closeSearch}>
 363:               <LightButtonLabel variant="caption">{'\u0417\u0430\u043A\u0440\u044B\u0442\u044C'}</LightButtonLabel>
 364:             </SmallButton>
 365:           </Inline>
 366:           <SearchRow>
 367:             <SearchInput
 368:               placeholder={'\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u043B\u043E\u0432\u043E \u043D\u0430 \u0440\u0443\u0441\u0441\u043A\u043E\u043C \u0438\u043B\u0438 \u0430\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u043E\u043C'}
 369:               placeholderTextColor="#9CA3AF"
 370:               value={query}
 371:               onChangeText={setQuery}
 372:               autoCapitalize="none"
 373:               autoCorrect={false}
 374:               returnKeyType="search"
 375:               onSubmitEditing={submitSearch}
 376:             />
 377:             <PrimaryButton onPress={submitSearch}>
 378:               <ButtonLabel>{'\u0418\u0441\u043A\u0430\u0442\u044C'}</ButtonLabel>
 379:             </PrimaryButton>
 380:           </SearchRow>
 381:           {searchError ? <Typography variant="caption" style={{ color: '#D32F2F' }}>{searchError}</Typography> : null}
 382:           {searchLoading && !results.length ? <ActivityIndicator size="small" color="#1E88E5" /> : null}
 383:           {!searchLoading && !results.length ? <Muted variant="caption">{'\u041D\u0430\u0447\u043D\u0438\u0442\u0435 \u043F\u043E\u0438\u0441\u043A, \u0447\u0442\u043E\u0431\u044B \u0443\u0432\u0438\u0434\u0435\u0442\u044C \u043F\u0435\u0440\u0435\u0432\u043E\u0434\u044B'}</Muted> : null}
 384:           {!!results.length && (
 385:             <FlatList
 386:               data={results}
 387:               keyExtractor={(it, idx) => `${it.word}-${it.translation}-${idx}`}
 388:               ItemSeparatorComponent={() => <Separator />}
 389:               renderItem={({ item }) => {
 390:                 const key = `${item.word.toLowerCase()}|${item.translation.toLowerCase()}`;
 391:                 const inDict = optimistic.has(key) || items.some((s) => s.word.toLowerCase() === item.word.toLowerCase() && s.translation.toLowerCase() === item.translation.toLowerCase());
 392:                 return (
 393:                   <WordCard padded>
 394:                     <Row>
 395:                       <Typography variant="subtitle">{item.word}</Typography>
 396:                       {item.transcription ? <Typography variant="caption">{item.transcription}</Typography> : null}
 397:                       {item.audioUrl ? (
 398:                         <AudioButton onPress={() => playAudio(`${key}-audio`, item.audioUrl!)}>
 399:                           <AudioLabel variant="caption">{playingId === `${key}-audio` ? '\u0421\u0442\u043E\u043F' : '\u041F\u0440\u043E\u0441\u043B\u0443\u0448\u0430\u0442\u044C'}</AudioLabel>
 400:                         </AudioButton>
 401:                       ) : null}
 402:                     </Row>
 403:                     <Row>
 404:                       <Typography>{'\u2014 '}{item.translation}{item.partOfSpeech ? ` (${item.partOfSpeech})` : ''}</Typography>
 405:                       {inDict ? (
 406:                         <SmallButtonLabel variant="caption">{'\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E'}</SmallButtonLabel>
 407:                       ) : (
 408:                         <SmallButton
 409:                           onPress={() => {
 410:                             if (!profile?.id) {
 411:                               Alert.alert('\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0432\u0445\u043E\u0434', '\u0412\u043E\u0439\u0434\u0438\u0442\u0435, \u0447\u0442\u043E\u0431\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0432 \u0441\u043B\u043E\u0432\u0430\u0440\u044C');
 412:                               return;
 413:                             }
 414:                             setOptimistic((prev) => { const next = new Set(prev); next.add(key); return next; });
 415:                             dispatch(
 416:                               addUserDictionaryEntry({
 417:                                 userId: profile.id,
 418:                                 entry: {
 419:                                   word: item.word,
 420:                                   translation: item.translation,
 421:                                   transcription: item.transcription,
 422:                                   partOfSpeech: item.partOfSpeech,
 423:                                   audioUrl: item.audioUrl,
 424:                                   sourceLang: 'en',
 425:                                   targetLang: 'ru',
 426:                                 },
 427:                               }) as any,
 428:                             );
 429:                           }}
 430:                         >
 431:                           <SmallButtonLabel variant="caption">{'\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C'}</SmallButtonLabel>
 432:                         </SmallButton>
 433:                       )}
 434:                     </Row>
 435:                   </WordCard>
 436:                 );
 437:               }}
 438:               style={{ maxHeight: panelHeight - 120 }}
 439:               showsVerticalScrollIndicator={false}
 440:             />
 441:           )}
 442:         </SearchPanel>
 443:       </Animated.View>
 444:     </Screen>
 445:   );
 446: };
